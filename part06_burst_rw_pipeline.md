# AXIバスのパイプライン回路設計ガイド ～ 第６回 Payloadの合流と優先順位の調停が必要なAXIリードライトの模擬

## 目次

- [AXIバスのパイプライン回路設計ガイド ～ 第６回 Payloadの合流と優先順位の調停が必要なAXIリードライトの模擬](#axiバスのパイプライン回路設計ガイド--第６回-payloadの合流と優先順位の調停が必要なaxiリードライトの模擬)
  - [目次](#目次)
  - [1. はじめに](#1-はじめに)
  - [2. 動作原理](#2-動作原理)
    - [2.1 リードライトの合流シナリオ](#21-リードライトの合流シナリオ)
    - [2.2 優先順位の調停シナリオ](#22-優先順位の調停シナリオ)
  - [3. リードライトが合流するパイプライン](#3-リードライトが合流するパイプライン)
  - [4. シーケンス　リードとライトが混在するバーストアクセスのシーケンス](#4-シーケンスリードとライトが混在するバーストアクセスのシーケンス)
  - [5. サンプルコード](#5-サンプルコード)
    - [5.1 リードライトパイプラインモジュール](#51-リードライトパイプラインモジュール)
    - [5.2 リードライトパイプラインテストベンチ](#52-リードライトパイプラインテストベンチ)
  - [6. 本質要素抽象化とは](#6-本質要素抽象化とは)
    - [6.1 抽象化の重要性](#61-抽象化の重要性)
    - [6.2 3つの基本要素](#62-3つの基本要素)
    - [6.3 ValidとPayloadの関係](#63-validとpayloadの関係)
    - [6.4 Readyによる制御の統一性](#64-readyによる制御の統一性)
  - [ライセンス](#ライセンス)

---

## 1. はじめに

このドキュメントはAIに読み込ませてコードを自動生成することを目標としています。

本記事では、パイプライン処理においてリードとライトのPayloadが合流し、優先順位の調停が必要な場合のAXIリードライトの動作を模擬します。前回までに学んだパイプライン処理の基本概念を応用し、実際のハードウェア設計でよく遭遇する「リードライト混在」シナリオを扱います。

リードライト混在は、リードリクエストとライトリクエストが同じパイプラインを通過するシナリオです。パイプラインの途中でリードとライトのPayloadが合流し、優先順位に基づいて処理順序を決定する必要があります。この優先順位の調停により、リードとライトの処理順序が制御され、データの整合性が保たれます。

AXIリードライトチャネルの特徴を整理します：

- **リードチャネル**: 読み出しアドレスとバースト情報を伝達
- **ライトチャネル**: 書き込みアドレス、データ、バースト情報を伝達
- **レスポンスチャネル**: 書き込み完了の応答を伝達

リード・ライト独立動作の場合は、第４回と第５回の両方を実装するだけですが、シングルポートのRAMにアクセス数る場合は、同一時間でのリード・ライト両方はできないため、順番を決めてRAMにアクセスします。パイプライン合流は第５回のライトのアドレス、データの合流と類似のロジックが使えます。違いはリードとライトのどちらを優先してどのような順番で実行するかという点です。

## 2. 動作原理

### 2.1 リードライトの合流シナリオ

リードライトの合流は、パイプライン処理においてリードリクエストとライトリクエストが同じパイプラインを通過する現象です。リードライトの合流の実装方法はすでに学んだ第５回のライトのアドレス、データの合流と同様の方法を使用します。

### 2.2 優先順位の調停シナリオ

優先順位の調停は、リードとライトのリクエストが同時に存在する場合に、どちらを優先して処理するかを決定する仕組みです。この調停により、リードとライトの処理順序が制御され、データの整合性が保たれます。

優先順位の調停方式には以下の3種類があります：

- **リード優先方式**: リードリクエストが常にライトリクエストより優先される
- **ライト優先方式**: ライトリクエストが常にリードリクエストより優先される  
- **ラウンドロビン方式（今回採用）**: リードとライトのリクエストを交互に処理する

ラウンドロビン方式では、リードとライトのリクエストを交互に処理します。この方式の特徴は以下の通りです：

- **メリット**: リードとライトの公平性が保たれる、スタベーションが発生しにくい
- **デメリット**: 最適なレイテンシが得られない場合がある
- **適用場面**: バランスの取れた性能が要求されるシステム、リードとライトの処理量が同程度の場合

**今回の実装方針**:
T0ステージで2つのフラグを使用して状態管理を行います：
- `prev_exec_flag`: 前回実行したリクエストの種類（0: リード、1: ライト）
- `current_state`: 現在の実行状態（0: アイドル、1: リード実行中、2: ライト実行中）

**フラグの動作**:
- `prev_exec_flag = 0`: 前回リード実行（Read）
- `prev_exec_flag = 1`: 前回ライト実行（Write）
- `current_state = 0`: アイドル状態
- `current_state = 1`: リード実行中
- `current_state = 2`: ライト実行中

**初期値**: 
- `prev_exec_flag = 0`（前回リード実行として開始）
- `current_state = 0`（アイドル状態として開始）

**調停ルール**:
1. 前回リード実行の場合は、次回はライトリクエストを優先
2. 前回ライト実行の場合は、次回はリードリクエストを優先
3. 片方のリクエストのみの場合は、そのリクエストを即座に処理
4. 現在実行中の状態に基づいて、次のリクエストの受け入れ可否を判断

この方式により、リードとライトの処理が公平に分配され、システム全体のバランスが保たれます。

## 3. リードライトが合流するパイプライン

本章では、リードライトが合流するパイプラインの構造について説明します。まず、ReadとWriteの各パイプラインの基本構造を説明し、その後で結合部分の動作について詳しく説明します。

### 3.1 Readパイプライン（part04_burst_read_pipeline.mdより）

Readパイプラインは2段構成で、データ増幅を行うパイプラインです。

#### T0ステージ（アドレスカウンタとRE制御）
- バースト転送の制御とアドレス生成
- 1つのPayload（アドレス）がバースト回数分に増幅（1→4個に増加）
- 上流に対するReady制御

#### T1ステージ（メモリアクセス）
- メモリからのデータ読み出し
- データ増幅なし（4個維持）
- 下流のd_Readyで制御される

**パイプライン構成**:
```
u_r_Payload -> [T0] -> [T1] -> d_r_Payload
                ^       ^
                |       |
u_r_Ready   <-[AND]<----+-- <- d_r_Ready
                ^
                |
            [T0_State_Ready]
```

### 3.2 Writeパイプライン（part05_burst_write_pipeline.mdより）

Writeパイプラインは4段構成で、2つのペイロードが合流するパイプラインです。

#### T0Aステージ（アドレスカウンタ）
- バースト転送の制御とアドレス生成
- 1つのPayload（アドレス）がバースト回数分に増幅（1→4個に増加）

#### T0Dステージ（データパイプライン）
- データのパイプライン処理
- データ増幅なし（4個維持）

#### T1ステージ（合流制御）
- T0AとT0Dのデータを適切なタイミングで合流
- アドレス、データ、WEの生成
- T0A_Valid && T0D_Valid の条件でValid生成

#### T2ステージ（レスポンス生成）
- 書き込み完了の応答生成
- アドレスとデータが一致し、書き込みが有効な場合のみアドレス値をレスポンスとして出力

**パイプライン構成**:
```
u_w_Payload_D=> [T0D]=======++
                 ^          ||
                 |          ||
u_w_Ready_D   <-[AND]---+   ||
                 ^      |   ||
                 |      |   ||
       [T0D_Ready]      |   ||
                        |   ||
u_w_Payload_A=> [T0A] ===> [T1] => [T2] => d_w_Payload
                 ^      |   ^       ^   
                 |      |   |       |   
u_w_Ready_A   <-[AND]<--+---+-------+--- <- d_w_Ready
                 ^ ^                     
                 | |        
       [T0A_Ready] |        
              [T0A_M_Ready]
```

### 3.3 結合部分の説明

リードライトパイプラインでは、ReadとWriteのパイプラインが合流し、優先順位の調停を行います。

**合流のポイント**:
- Readパイプライン: T0 → T1 → 出力
- Writeパイプライン: T0A → T0D → T1 → T2 → 出力
- 両パイプラインがT1ステージで合流

**T1ステージでの結合**:
- T1のアドレスが結合される
- RE（Read Enable）とWE（Write Enable）は排他的にアサート可能
- T0ステージに入力されるRead側のValidとWrite側のValidとT0で制御される`prev_exec_flag`、`current_state`から`t0_r_ready`と`t0_w_ready`を作成

**優先順位の調停**:
- T0ステージで`prev_exec_flag`フラグによる前回実行の記録を管理
- T0ステージで`current_state`フラグによる現在の実行状態を管理
- 前回の実行と異なる側のリクエストを優先
- 現在実行中の状態に基づくリクエスト受け入れ制御
- ラウンドロビン方式による公平な処理分配

**制御の統合**:
- リードパイプラインは`d_r_ready`信号で制御
- ライトパイプラインは`d_w_ready`信号で制御
- T0ステージで`prev_exec_flag`と`current_state`フラグを管理し、T1ステージに送るRead用Valid（r_T1_Valid）とWrite用Valid（w_T1_Valid）とアドレスを制御
- 各ステージの動作はReadyがHの時のみ実行
- 複数のReady信号の非同期ANDによる制御統合

## 4. シーケンス　リードとライトが混在するバーストアクセスのシーケンス
```
[Write]------------------------------------
Clock           : 12345678901234567890123456
w_T0A_Count     : FFFFFFF321033333210FFFFFFF
w_T0A_Valid     : _______HHHHHHHHHHHH_______
w_T0A_Last      : __________H_______H_______
w_T0A_Ready     : HHHHHHH___H_______HHHHHHHH

w_T1_Address    : xxxxxxxx012333334567777xxx
w_T1_Valid      : ________HHHHHHHHHHHH______
w_T1_Last       : ___________H_______H______

[Flag]--------------------------------------
next_state      : IIIIIIIWWWwRRRrWWWwRRRrIII
current_state   : IIIIIIIIWWWwRRRrWWWwRRRrII
t1_w_ready      : HHHHHHHHHHH____HHHH____HHH
t1_r_ready      : HHHHHHH____HHHH____HHHHHHH

[Read]--------------------------------------
r_T0A_Count     : FFFFFFF3333321033333210FFF
r_T0_Valid      : _______HHHHHHHHHHHHHHHH___
r_T0_Last       : ______________H_______H___

r_T1_Address    : xxxxxxxx0000012344444567xx
r_T1_Valid      : ________HHHHHHHHHHHHHHHH__
r_T1_Last       : _______________H_______H__
```

## 5. サンプルコード
AIに以下のように指示してコードを作成。
```
ここまでのドキュメントの記述を読んで、コードを実装してください。モジュール名はburst_rw_pipeline、ファイル名はburst_rw_pipeline.vとします。２つのソースコードburst_write_pipeline.v、burst_read_pipeline.vを改良して新しいファイルの中に記述して、そこに追加の機能を実装してください。参照する２つのファイルには同じ信号名が出てきますので仕様書を注意深く読んで信号のリネームを行ってください。リードとライトの両方にT1ステージを挿入して、このT1ステージを優先順位の調停に使用します。

テストベンチはburst_read_pipeline_tb.svとburst_write_pipeline_tb.svの構造とテスト内容をそのまま継承してください。
```
### 5.1 リードライトパイプラインモジュール

### 5.2 リードライトパイプラインテストベンチ

## 6. 本質要素抽象化とは

### 6.1 抽象化の重要性

### 6.2 3つの基本要素

### 6.3 ValidとPayloadの関係

### 6.4 Readyによる制御の統一性

---

## ライセンス

Licensed under the Apache License, Version 2.0 - see [LICENSE](LICENSE) file for details.
