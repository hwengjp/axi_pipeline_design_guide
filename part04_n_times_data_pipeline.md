# AXIバスのパイプライン回路設計ガイド ～ 第４回 データがN倍に増えるパイプランAXIデータチャネルの模擬

## 目次

- [AXIバスのパイプライン回路設計ガイド ～ 第４回 データがN倍に増えるパイプランAXIデータチャネルの模擬](#axiバスのパイプライン回路設計ガイド--第４回-データがn倍に増えるパイプランaxiデータチャネルの模擬)
  - [目次](#目次)
  - [1. はじめに](#1-はじめに)
  - [2. 動作原理](#2-動作原理)
    - [2.1 データ増幅とは](#21-データ増幅とは)
    - [2.2 通常のReadyのシーケンス](#22-通常のreadyのシーケンス)
    - [2.3 Payloadが３つに増える場合のシーケンス](#23-payloadが３つに増える場合のシーケンス)
      - [パイプライン構成](#パイプライン構成)
    - [2.2 パイプラン設計上の課題](#22-パイプラン設計上の課題)
    - [2.3 AXIデータチャネルの拡張](#23-axiデータチャネルの拡張)
  - [3. AXIバースト転送の設計](#3-axiバースト転送の設計)
  - [4. バーストアクセスモジュールの実装](#4-バーストアクセスモジュールの実装)
  - [5. テストベンチの設計と実装](#5-テストベンチの設計と実装)
  - [6. シミュレーション結果の分析](#6-シミュレーション結果の分析)
  - [7. 実用的な応用例](#7-実用的な応用例)
  - [ライセンス](#ライセンス)

---

## 1. はじめに

このドキュメントはAIに読み込ませてコードを自動生成することを目標としています。

本記事では、パイプラン処理においてデータがN倍に増える場合のAXIデータチャネルの動作を模擬します。前回までに学んだパイプラン処理の基本概念を応用し、実際のハードウェア設計でよく遭遇する「バーストアクセス」シナリオを扱います。

バーストアクセスは、1つのアドレスリクエストに対して複数のデータ応答が返されるシナリオです。パイプランの途中で1つのペイロード（アドレスに対するデータ）がバースト回数分に膨らみます。このような状況では、ペイロードの個数が増えるパイプラインステージより上流のパイプラインを停止して待機させる必要があります。できるだけ無駄なサイクルが発生しない実装を考えます。

## 2. 動作原理

### 2.1 データ増幅とは

データ増幅とは、パイプラン処理において1つの入力データが複数の出力データに変換される現象です。特に**バーストアクセス**では、1つのリクエストに対して複数のデータ応答が返されます：

### 2.2 通常のReadyのシーケンス

第１回で学んだReadyのシーケンスをおさらいしましょう。
シーケンスチャートを簡便にするためにデータもアドレスもPayloadと呼ぶことにします。
ReadyがHの時はデータを受信し、ReadyがLの時はパイプラインは停止（ストール）します。ValidがHの時はデータが有効、ValidがLの時はデータは無効です。
```
Clock    : 123456789012345678
Payload  : xxxxxx0001222345xx
Valid    : ______HHHHHHHHHH__
Ready    : HHHHHH__HH__HHHHHH
```

下の図は４段パイプラインです。上で説明したReadyとValidのルールはパイプラインのどこを輪切りにしても同じルールになっています。
```
Payload -> [T0] -> [T1] -> [T2] -> [T3] -> Payload
            |       |       |       |
Ready   <- -+-------+-------+-------+-- <- Ready
```

### 2.3 Payloadが３つに増える場合のシーケンス

ペイロードが２つに増えるシナリオつまり、バースト長２のリードシーケンスを考えてみます。

#### パイプライン構成

| 段階 | 機能 | 説明 | データ増幅 |
|------|------|------|------------|
| T0 | アドレスとバースト長をラッチ | リクエストの基本情報を保持 | なし |
| T1 | アドレスカウンタとRE | バースト転送の制御とアドレス生成 | **1→2個に増加** |
| T2 | メモリアクセス | メモリからのデータ読み出し | 3個維持 |
| T3 | メモリのリードデータ | 読み出されたデータの出力 | 3個維持 |
```
アドレスは0から+2インクリメントで送られて、データチャネルでアドレスチャネルから受け取ったAddressとAddress+1の２つのアクセスを生成します。
```
Clock       : 123456789012345678
Address     : xxxxxx022334455xx
Length      : xxxxxx222222222xx
Valid       : ______HHHHHHHHH__
Ready       : HHHHHHH_H_H_H_HHH

T0_Address  : xxxxxxx00022334455xx
T0_Length   : xxxxxxx3333333333xx
T0_Valid    : _______HHHHHHHHHH__
T0_Ready    : HHHHHHH_H_H_H_H_HHH



```
```

### 2.2 パイプラン設計上の課題

データ増幅が発生するパイプランでは、以下の課題が生じます：

1. **データフロー制御**
   - 上流から送られてくる増幅データの適切な処理
   - 下流への適切な転送タイミング

2. **リソース管理**
   - 増幅されたデータを格納するバッファ容量
   - 処理能力の配分

3. **同期制御**
   - 複数データの同時処理
   - データ間の依存関係の管理

### 2.3 AXIデータチャネルの拡張

標準的なAXIデータチャネルを拡張して、データ増幅に対応する設計を考えます：

```systemverilog
// 拡張されたAXIデータチャネル
typedef struct packed {
    logic [31:0] data;      // データ
    logic [3:0]  id;        // ID
    logic [3:0]  dest;      // 宛先
    logic        last;       // 最後のデータ
    logic [1:0]  count;     // データ数（増幅時）
} axi_data_t;
```

この拡張により、以下の機能が実現できます：

- **複数データの同時転送**: `count`フィールドでデータ数を指定
- **宛先指定**: `dest`フィールドで処理先を指定
- **バッチ処理**: `last`フィールドでバッチの終了を通知

次節では、この拡張されたAXIデータチャネルを使用した具体的な実装について説明します。

## 3. AXIバースト転送の設計

（このセクションの内容は今後の執筆で追加予定）

## 4. バーストアクセスモジュールの実装

（このセクションの内容は今後の執筆で追加予定）

## 5. テストベンチの設計と実装

（このセクションの内容は今後の執筆で追加予定）

## 6. シミュレーション結果の分析

（このセクションの内容は今後の執筆で追加予定）

## 7. 実用的な応用例

（このセクションの内容は今後の執筆で追加予定）

## ライセンス

このプロジェクトは [Apache License 2.0](LICENSE) の下で公開されています。 