# AXIバス設計ガイド 第13回 AXI4バス・テストベンチのバイトアクセス検証機能

## 目次

  - [1. はじめに](#1-はじめに)
  - [2. バイトアクセス検証の概要](#2-バイトアクセス検証の概要)
  - [3. 実装方針とアーキテクチャ](#3-実装方針とアーキテクチャ)
  - [4. コード](#4-コード)
  - [5. まとめ](#5-まとめ)
  - [ライセンス](#ライセンス)

---

## 1. はじめに

このドキュメントは、第11回で実装したAXI4バス・テストベンチの拡張ストローブ制御機能を基盤として、より詳細なメモリアクセス検証を実現する第13回の内容を説明します。

### **第13回の主要なテーマ**

第11回では、拡張ストローブ制御機能により、様々なストローブパターンでのテストが可能になりました。しかし、実際のハードウェア設計においては、より細かいレベルでのメモリアクセスの正確性を検証する必要があります。

#### **1. バイト単位アクセス検証の重要性**

現代のSoC設計において、異なるデータ幅でのメモリアクセスが混在する状況は一般的です。例えば：
- **32ビットバス**で8ビットデータを書き込み、その後**8ビットアクセス**で読み出し
- **64ビットバス**で16ビットデータを書き込み、**バイト単位**で検証
- **128ビットバス**で32ビットデータを書き込み、**ワード単位**で確認

このような状況で、正しいメモリアドレスにデータが書き込まれているかを確実に検証する必要があります。

#### **2. 従来の実装の制限**

第11回までのテストベンチでは、以下の制限がありました：

- **バースト転送中心**: 大きなデータブロックでの転送検証が中心
- **バイトレベル検証不足**: 個別のバイトやワードレベルでの正確性確認が困難
- **アクセス形式の固定**: READとWRITEのアクセス形式が固定されており、柔軟性に欠ける

#### **3. 第13回で実現する機能**

##### **READアクセスの柔軟化**
- **バーストモード**: 従来の連続アクセス（第11回の実装）
- **バイト分解モード**: バースト転送を個別のバイトアクセスに分解
- **ワード分解モード**: バースト転送を個別のワードアクセスに分解

##### **WRITEアクセスの多様化**
- **従来のバーストモード**: 第11回で実装済み
- **バイト単位書き込み**: 個別のバイトを指定して書き込み
- **ワード単位書き込み**: 個別のワードを指定して書き込み

##### **検証機能の強化**
- **アドレス正確性検証**: 書き込まれたデータが正しいアドレスに配置されているかの確認
- **データ整合性検証**: 異なるアクセス形式での読み出し結果の一致確認
- **境界条件テスト**: アドレス境界での動作確認

#### **4. 技術的な特徴**

##### **柔軟なアクセス制御**
- パラメータによるアクセスモードの切り替え
- 実行時の動的なモード変更
- テストケースごとの最適化されたアクセスパターン

##### **包括的な検証機能**
- バイトレベルでの正確性確認
- ストローブ信号の詳細検証
- アドレスアライメントの境界条件テスト

##### **実装の保守性**
- 第11回の基盤コードの継承
- モジュール化された機能追加
- 設定による動作の制御

### **期待される効果**

#### **品質向上**
- メモリアクセスの正確性をバイトレベルで確認
- 境界条件での動作を詳細に検証
- 実装の信頼性向上

#### **開発効率の向上**
- 問題の早期発見
- デバッグ時間の短縮
- 設計品質の向上

#### **再利用性の向上**
- 様々なプロジェクトでの活用
- カスタマイズ可能な検証機能
- 拡張性の確保

この拡張により、AXI4プロトコルの実装品質をより高精度に検証できる、包括的で柔軟なテストベンチが完成します。適切な設定により、効率的で包括的なバイトレベル検証が可能になり、ハードウェア設計の品質向上に大きく貢献します。

### **レポートで使用するアドレス範囲の表示**

#### **メモリ設定パラメータ**
- **メモリサイズ**: 32MB (33,554,432バイト)
- **テスト回数**: 800回
- **テスト1回あたりのアドレスサイズ**: 4KB (4,096バイト)

#### **アドレス範囲の計算**
```
800テスト × 4KB = 800 × 4,096 = 3,276,800バイト = 3.125MB
```

#### **アドレス範囲の詳細**
- **開始アドレス**: 0x00000000
- **終了アドレス**: 0x00000000 + 3,276,800 - 1 = 0x0031FFFF
- **最大利用可能アドレス**: 0x01FFFFFF (32MB - 1)
- **アドレス幅**: 25ビット ($clog2(33,554,432) = 25)

#### **安全性の確認**
- **必要なアドレス範囲**: 3.125MB
- **利用可能なメモリ**: 32MB
- **余裕**: 約28.875MB (90.2%の余裕)
- **アドレスオーバーフロー**: 発生しない
- **テストの連続性**: 問題なく実行可能

#### **レポートでの表示例**
```
=== メモリアドレス範囲レポート ===
メモリサイズ: 32MB (0x02000000)
テスト回数: 800回
テスト1回あたり: 4KB
総必要アドレス: 3.125MB (0x00320000)
開始アドレス: 0x00000000
終了アドレス: 0x0031FFFF
アドレス幅: 25ビット
安全性: 90.2%の余裕あり
===============================
```

このアドレス範囲の表示により、テスト実行時のメモリ使用状況を明確に把握でき、レポート作成時の参考情報として活用できます。

## 2. バイトアクセス検証の概要

## 3. 実装方針とアーキテクチャ

### **3.1 バイト単位検証の実装方針**

第13回では、シンプルで効率的なバイト単位検証を実現するため、以下の方針で実装を進めます。

#### **基本設計原則**
1. **シンプル性の重視**: バイト単位のみの実装で複雑性を排除
2. **既存コードの継承**: 第11回の基盤コードを最大限活用
3. **段階的な機能追加**: 既存のテスト完了後にバイト検証を実行
4. **保守性の向上**: 明確で理解しやすいコード構造

#### **実装対象の限定**
- **READアクセス**: バイト単位の読み出しのみ
- **WRITEアクセス**: 既存のバースト転送を継承
- **検証対象**: 書き込まれたデータのバイトレベル正確性

### **3.2 アーキテクチャ設計**

#### **制御フラグ設計**
```systemverilog
// バイト検証モードの制御フラグ
byte_verification_enable      // バイト検証モードの有効/無効制御
byte_verification_start       // バイト検証の開始信号
byte_verification_done        // バイト検証の完了信号
byte_verification_active      // バイト検証が実行中かどうかの状態
```

#### **データ構造体設計**
```systemverilog
// バイト検証用リードアドレスペイロード構造体
typedef struct {
    int                         test_count;    // テストシーケンス番号
    logic [AXI_ADDR_WIDTH-1:0] addr;          // AXIアドレス（バイト単位）
    logic [2:0]                size;          // 転送サイズ（常に0 = 1バイト）
    logic [AXI_ID_WIDTH-1:0]   id;            // AXI ID
    logic [7:0]                len;           // バースト長（常に0 = 1転送）
    logic                      valid;         // Valid信号
    int                         phase;         // テストフェーズ番号
} byte_verification_read_addr_payload_t;

// バイト検証用期待値構造体
typedef struct {
    int                         test_count;    // テストシーケンス番号
    logic [7:0]                expected_byte; // 期待されるバイト値（8ビット固定）
    logic [AXI_ADDR_WIDTH-1:0] byte_addr;     // バイトアドレス
    int                         phase;         // テストフェーズ番号
} byte_verification_expected_t;
```

#### **配列設計**
```systemverilog
// バイト検証用配列
byte_verification_read_addr_payload_t byte_verification_read_addr_payloads[int];
byte_verification_expected_t byte_verification_expected[int];
```

### **3.3 実装の流れ**

#### **フェーズ1: 通常テスト実行**
1. 第11回の拡張ストローブ制御機能による通常テスト実行
2. 800回のテストケースを実行
3. 全てのフェーズ（Write Address, Write Data, Write Response, Read Address, Read Data）の完了を確認

#### **フェーズ2: バイト検証準備**
1. 通常テスト完了後、`byte_verification_start`をアサート
2. 書き込まれたデータを基にバイト単位の読み出し配列を生成
3. 各テストケースで書き込まれたデータの期待値を計算

#### **フェーズ3: バイト検証実行**
1. 生成された配列を使用してバイト単位で読み出し
2. 1バイトずつメモリから読み出し
3. 読み出したデータと期待値を比較
4. 不一致があればエラーログを出力

#### **フェーズ4: 検証完了**
1. 全てのバイト検証が完了
2. `byte_verification_done`をアサート
3. 検証結果のサマリーを出力
4. シミュレーション終了

### **3.4 技術的特徴**

#### **シンプルな実装**
- **バイト単位固定**: 8ビット固定で複雑なストローブ制御が不要
- **単一アクセス**: バースト転送ではなく1バイトずつの個別アクセス
- **明確な制御**: 開始・実行中・完了の3状態で制御

#### **効率的な検証**
- **既存コード活用**: 第11回の基盤コードを最大限活用
- **段階的実行**: 通常テスト完了後にバイト検証を実行
- **メモリ効率**: 必要最小限の配列で検証を実現

#### **保守性の向上**
- **明確な構造**: バイト検証専用の構造体と配列
- **独立した制御**: 既存のテストと分離された制御フロー
- **拡張性**: 将来の機能追加に対応可能な設計

### **3.5 設定パラメータ**

```systemverilog
// バイト検証モードの設定
parameter BYTE_VERIFICATION_ENABLE = 1'b1;     // バイト検証モードの有効化
```

## 4. コード

## 5. まとめ

## ライセンス

Licensed under the Apache License, Version 2.0 - see [LICENSE](https://www.apache.org/licenses/LICENSE-2.0) file for details.
