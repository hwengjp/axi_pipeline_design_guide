# AXI4 SIZEとWRAPの仕様

## 概要

ARM公式仕様書「IHI0022B_AMBAaxi.txt」の確認結果に基づき、PART11のAXI4テストベンチ実装におけるSIZE制約の問題点と修正要件を整理します。

## 1. ARM公式仕様書での確認結果

### 1.1 基本仕様

#### Chapter 4.3「Burst size」
- **転送サイズ**: 各転送のバイト数（1〜128バイト）を指定
- **バス幅制約**: 「転送サイズはバス幅を超えてはいけないが、小さい分には問題ない」
- **明記**: "The size of any transfer must not exceed the data bus width of the components in the transaction."

#### Chapter 9.3「Narrow transfers」
- **部分転送**: 転送サイズがバス幅より小さい場合の処理
- **バイトレーン制御**: アドレスと制御情報による使用バイトレーンの決定
- **図解例**: 8ビット転送を32ビットバスで行うケース

#### Chapter 2.2/2.5「Signal Descriptions」
- **SIZE信号**: バーストサイズは8〜1024ビット（1〜128バイト）
- **範囲**: バス幅より小さいサイズも含む

### 1.2 技術的な動作

#### WSTRB（ライトストローブ）の役割
- **有効バイト指定**: 使用するバイトの明示
- **部分書き込み**: バス幅の一部のみを使用した転送
- **アドレスアライメント**: 正しい境界でのアクセス

#### バースト転送での動作
- **各ビート**: 異なるバイトレーンの使用
- **アドレス計算**: SIZEに基づく適切な増分
- **一貫性**: バースト中のSIZE変更なし





## 4. AXI4 WRAPバーストの仕様詳細

### 4.1 WRAPバーストの定義（Chapter 4.4.3）

WRAPバーストは、アドレスが一定の境界を超えると、下位アドレスに巻き戻る（wrap）動作をします。

各転送のアドレスは、前の転送のアドレス + 転送サイズ（Number_Bytes）で計算されますが、Wrap_Boundaryを超えると、アドレスが境界の先頭に戻ります。

#### ✅ WRAPバーストの制約
- **開始アドレス**: 転送サイズにアラインされている必要がある
- **バースト長**: 2, 4, 8, 16 のいずれかでなければならない
- **Wrap_Boundary**: Number_Bytes × Burst_Length

**例**: 転送サイズが4バイト、バースト長が4なら、Wrap_Boundaryは16バイト

### 4.2 WRAP時のアドレス計算式（Chapter 4.5）

仕様書では以下のような式が提示されています：

```
Wrap_Boundary = INT(Start_Address / (Number_Bytes × Burst_Length)) × (Number_Bytes × Burst_Length)
Address_N = Wrap_Boundary + ((Start_Address + (N – 1) × Number_Bytes) MOD (Number_Bytes × Burst_Length))
```

この式により、N番目の転送アドレスがWrap_Boundaryを超えると、MOD演算によってアドレスが境界内に巻き戻されます。

### 4.3 WRAPバーストの図解例（Chapter 10.2）

仕様書の Figure 10-3 に、64ビットバス上でのWRAPバーストの例が示されています：

- **開始アドレス**: 0x04
- **転送サイズ**: 32ビット（4バイト）
- **バースト長**: 4
- **バーストタイプ**: WRAP

この例では、転送が進むにつれてアドレスが増加し、4回目の転送でアドレスがWrap_Boundaryに戻る様子が図で示されています。

### 4.4 技術的な意味合い

WRAPバーストは主に以下の用途で使われます：

- **キャッシュラインのフェッチ**: 例：128バイトのキャッシュラインを16回の8バイト転送で取得
- **リングバッファのような構造へのアクセス**: アドレス境界を越えない連続アクセスの最適化
- **メモリ効率の向上**: 境界内での連続アクセスによる最適化


## 7. 具体的な動作例

### 7.1 SIZE=0（1バイト）の場合

#### アドレス0x01（64ビットバス）
```verilog
// アドレス境界: 丸めなし（1バイト単位）
aligned_addr = 0x01;  // 丸めなし
offset = 0x01 - 0x01 = 0;

// 有効バイト位置: bit8~15（アドレス0x01に対応）
strobe = 8'b0000_0010;  // bit1のみ1
```

#### アドレス0x02（64ビットバス）
```verilog
// アドレス境界: 丸めなし（1バイト単位）
aligned_addr = 0x02;  // 丸めなし
offset = 0x02 - 0x02 = 0;

// 有効バイト位置: bit16~23（アドレス0x02に対応）
strobe = 8'b0000_0100;  // bit2のみ1
```

### 7.2 SIZE=1（2バイト）の場合

#### アドレス0x01（64ビットバス）
```verilog
// アドレス境界: 2バイト境界で丸め
aligned_addr = (0x01 / 2) * 2 = 0x00;  // 下位1ビットを丸め
offset = 0x01 - 0x00 = 1;

// 有効バイト位置: bit8~15（2バイト連続）
strobe = 8'b0000_0011;  // bit0,1が1
```

#### アドレス0x02（64ビットバス）
```verilog
// アドレス境界: 2バイト境界で丸め
aligned_addr = (0x02 / 2) * 2 = 0x02;  // 下位1ビットを丸め
offset = 0x02 - 0x02 = 0;

// 有効バイト位置: bit16~23（2バイト連続）
strobe = 8'b0000_1100;  // bit2,3が1
```

### 7.3 SIZE=2（4バイト）の場合

#### アドレス0x01（64ビットバス）
```verilog
// アドレス境界: 4バイト境界で丸め
aligned_addr = (0x01 / 4) * 4 = 0x00;  // 下位2ビットを丸め
offset = 0x01 - 0x00 = 1;

// 有効バイト位置: bit8~31（4バイト連続）
strobe = 8'b0000_1111;  // bit0,1,2,3が1
```


## ライセンス

Licensed under the Apache License, Version 2.0 - see [LICENSE](https://www.apache.org/licenses/LICENSE-2.0) file for details.
