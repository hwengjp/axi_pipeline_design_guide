# AXIバス設計ガイド 第４回 ペイロードがN倍に増えるパイプラインAXIリードアドレスチャネルの模擬

## 目次

  - [目次](#目次)
  - [1. はじめに](#1-はじめに)
  - [2. 動作原理](#2-動作原理)
    - [2.1 ペイロード増幅とは](#21-ペイロード増幅とは)
    - [2.2 通常のReadyのシーケンス](#22-通常のreadyのシーケンス)
    - [2.3 Payloadが４つに増える場合のシーケンス](#23-payloadが４つに増える場合のシーケンス)
      - [パイプライン構成](#パイプライン構成)
  - [3. コード](#3-コード)
    - [3.1 バーストリードパイプラインモジュール](#31-バーストリードパイプラインモジュール)
    - [3.2 バーストリードパイプラインテストベンチ](#32-バーストリードパイプラインテストベンチ)
    - [3.3 実行用スクリプト](#33-実行用スクリプト)
  - [ライセンス](#ライセンス)

---

## 1. はじめに

このドキュメントはAIに読み込ませてコードを自動生成することを目標としています。

本記事では、パイプライン処理においてペイロードがN倍に増える場合のAXIリードアドレスチャネルの動作を模擬します。前回までに学んだパイプライン処理の基本概念を応用し、実際のハードウェア設計でよく遭遇する「バーストアクセス」シナリオを扱います。

バーストアクセスは、1つのアドレスリクエストに対して複数のデータ応答が返されるシナリオです。パイプラインの途中で1つのPayload（アドレス）がバースト回数分に膨らみます。このような状況では、Payloadの個数が増えるパイプラインステージより上流のパイプラインを停止して待機させる必要があります。できるだけ無駄なサイクルが発生しない実装を考えます。

## 2. 動作原理

### 2.1 ペイロード増幅とは

ペイロード増幅とは、パイプライン処理において1つの入力データが複数の出力データに変換される現象です。特に**バーストアクセス**では、1つのリクエストに対して複数のデータ応答が返されます。

**ペイロード増幅の特徴**:
- **発生箇所**: パイプラインの特定のステージでのみ発生
- **増幅パターン**: 1つの入力がN個の出力に変換（N > 1）
- **制御の重要性**: 増幅が発生するステージより上流のパイプラインを停止させる必要がある

**本設計でのペイロード増幅**:
- **T0ステージ**: 1つのバーストリクエスト（アドレス+長さ）→ 複数のメモリアクセス
- **T1ステージ**: ペイロード増幅なし（単純なメモリ読み出し）

### 2.2 通常のReadyのシーケンス

第１回で学んだReadyのシーケンスをおさらいしましょう。
シーケンスチャートを簡便にするためにデータもアドレスもPayloadと呼ぶことにします。
ReadyがHの時はデータを受信し、ReadyがLの時はパイプラインは停止（ストール）します。ValidがHの時はデータが有効、ValidがLの時はデータは無効です。
```
Clock    : 123456789012345678
Payload  : xxxxxx0001222345xx
Valid    : ______HHHHHHHHHH__
Ready    : HHHHHH__HH__HHHHHH
```
下の図は４段パイプラインです。上で説明したReadyとValidのルールはパイプラインのどこを輪切りにしても同じルールになっています。
```
Payload -> [T0] -> [T1] -> [T2] -> [T3] -> Payload
            |       |       |       |
Ready   <- -+-------+-------+-------+-- <- Ready
```

### 2.3 Payloadが４つに増える場合のシーケンス

Payloadが４つに増えるシナリオつまり、バースト長４のリードシーケンスを考えてみます。

#### パイプライン構成

T0はアドレスをカウントする回路。ここで上流に対するReadyの制御を行います。T1は下流のd_readyで制御されると同時に、上流に対するu_Readyを生成します。u_Readyは今までのルールであるd_ReadyがU_Readyに非同期でつながる回路に、T0でバースト中に待たせるためのT0_State_Readyを非同期で論理ANDした信号です。T0_State_ReadyはT0ステージで同期回路で生成します。
T1はメモリです。Read Enableとアドレスをラッチして次のクロックでデータを出力します。T1は下流のd_Readyで制御されます。

**重要な設計ポイント**: この回路では、パイプライン全体がReady信号で制御されており、各ステージの動作は`d_ready`がHの時のみ実行されます。また、T0ステージから派生する制御信号（`t0_mem_read_en`、`t0_last`、`t0_state_ready`）は、`t0_count`の値をデコードして生成されるため、always文内での複雑な制御ロジックが不要になり、コードがすっきりしています。

**Ready制御の特徴**: 各ステージのalways文は`d_ready`がHの時のみ実行され、パイプライン全体がReady信号で統一的に制御されています。また、T0ステージの制御は`t0_state_ready`信号に基づいて行われ、より直感的な制御フローを実現しています。

```
u_Payload -> [T0] -> [T1] -> d_Payload
              ^       ^
              |       |
u_Ready   <-[AND]<----+-- <- d_Ready
              ^
              |
          [T0_State_Ready]
```
| 段階 | 機能 | 説明 | ペイロード増幅 |
|------|------|------|------------|
| T0 | アドレスカウンタとRE | バースト転送の制御とアドレス生成 | **1→４個に増加** |
| T1 | メモリアクセス| メモリからのデータ読み出し | **増幅なし**（4個維持） |

#### バースト長４、d_readyがH のシーケンス

アドレスは0から+4インクリメントで送られて、T0でAddress~Address+3の4つのアクセスを生成します。
Lengthはバースト長-1の値です。下流からのd_readyはHの場合です。

T0_State_Readyは2つの状態で管理されます。

| 状態 | 状態名 | 条件 | 動作 |
|------|--------|------|------|
| 1 | リクエスト受付可能 | T0_Count=0xFFまたはT0_Count=0x00 | アイドルまたはバーストの最後のサイクル |
| 0 | バースト中 | T0_Countが0xFFでも0x00でもない | バースト転送を実行中 |

**初期値**: 状態=1（リクエスト受付可能）、T0_Count=0xFF、T0_Mem_Adr=0、T0_Mem_RE=L、T0_LAST=L、T0_State_Ready=H

**状態1（リクエスト受付可能）**: T0_u_Ready && T0_u_ValidでAddressとLengthから以下を生成
- T0_Count ← Lengthの値
- T0_Mem_Adr ← Addressの値

**状態0（バースト中）**: T0_Countをデクリメントし、アドレスをインクリメント
- T0_Count ← T0_Count - 1
- T0_Mem_Adr ← T0_Mem_Adr + 1

**制御信号の生成**: 以下の信号は`t0_count`の値をデコードして生成されます：
- `t0_state_ready`: `(t0_count == 8'hFF) || (t0_count == 8'h00)` - アイドルまたは最終サイクルの時のみH
- `t0_last`: `(t0_count == 8'h00)` - カウンタが0の時のみH
- `t0_mem_read_en`: `(t0_count != 8'hFF)` - アイドル状態以外でメモリ読み取り有効

```
Clock         : 123456789012345678901
Address       : xxxxxx044448888xxxxxx
Length        : xxxxxx333333333xxxxxx
Valid         : ______HHHHHHHHHHHH___
Ready         : HHHHHHH___H___H___HHH

T0_Count      : FFFFFFF321032103210FF
T0_Mem_Adr    : xxxxxxx0123456789ABxx
T0_Mem_RE     : _______HHHHHHHHHHHH__
T0_Valid      : _______HHHHHHHHHHHH__
T0_Last       : __________H___H___H__
T0_State_Ready: HHHHHHH___H___H___HHH
u_Ready       : HHHHHHH___H___H___HHH

d_Data        : _______0123456789AB__
d_Valid       : _______HHHHHHHHHHHH__
d_Last        : __________H___H___H__
d_Ready       : HHHHHHHHHHHHHHHHHHHHH
```

#### バースト長４、d_readyがトグルするシーケンス

T0とT1はどちらもd_readyで論理全体のイネーブル制御を行います。T0_State_Readyもこのd_readyでイネーブル制御されます。

**Ready制御の特徴**: 各ステージのalways文は`d_ready`がHの時のみ実行され、パイプライン全体がReady信号で統一的に制御されています。また、T0ステージの制御は`t0_state_ready`信号に基づいて行われ、より直感的な制御フローを実現しています。

```
Clock         : 123456789012345678901234567890123456
Address       : xxxxxx044444444888888888xxxxxxxxxxxx
Length        : xxxxxx333333333333333333xxxxxxxxxxxx
Valid         : ______HHHHHHHHHHHHHHHHHH____________
Ready         : HHHHHHH_______H________H_______HHHHH

T0_Count      : FFFFFFF3322110033322110033221100FFFF
T0_Mem_Adr    : xxxxxxx001122334445566778899AABBxxxx
T0_Mem_RE     : _______HHHHHHHHHHHHHHHHHHHHHHHHH____
T0_Valid      : _______HHHHHHHHHHHHHHHHHHHHHHHHH____
T0_Last       : _____________HH_______HH______HH____
T0_State_Ready: HHHHHHH______HH_______HH______HHHHHH
u_Ready       : HHHHHHH_______H________H_______HHHHH

d_Data        : xxxxxxxxx001122333445566778899AABB__
d_Valid       : _________HHHHHHHHHHHHHH_____________
d_Last        : _______________HHH______HH______HH__
d_Ready       : HHHHHHH_H_H_H_H__H_H_H_H_H_H_H_H_HHH
```

## 3. コード

以下の指示でコードとテストベンチを生成します。
```
メモリはリードのみ、レイテンシ１、出力のデータ＝アドレスとします。パイプラインの入力アドレスとメモリのアドレスは同じとします。
ポート定義はクロック、リセット、パイプラインの最上流の信号、パイプラインの最下流の信号としてください。
このドキュメントを読んでコードを生成してください。

テストベンチも実装お願いします。テストベンチはpipeline_tb.svを参考にしてください。
テストデータと期待値は最初に配列として用意しておきます。配列はqueue型配列を使用してください。
```
ここまでの説明を読み込ませてAIに自動生成させたコードです。たった２段のパイプラインですので非常にシンプルです。
このコードはアドレスチャネルと、データチャネルが合体しています。分離する方法として例えば、pipeline_insertモジュールをアドレスチャネルとする方法もあるでしょうし、アドレスチャネルとしてFIFOを使う方法もあるでしょう。

**コードの特徴**:
1. **Ready制御**: パイプライン全体が`d_ready`信号で制御されており、各ステージの動作はReadyがHの時のみ実行されます
2. **デコードベース制御**: T0ステージから派生する制御信号（`t0_mem_read_en`、`t0_last`、`t0_state_ready`）は、`t0_count`の値をデコードして生成されます
3. **シンプルなalways文**: 複雑な制御ロジックがalways文内に含まれておらず、コードがすっきりしています
4. **統一的制御**: パイプライン全体が一つのReady信号で統一的に制御されています

### 3.1 バーストリードパイプラインモジュール

**コード**: [burst_read_pipeline.v](https://github.com/hwengjp/axi_pipeline_design_guide/blob/main/burst_read_pipeline.v)

**コードの特徴**:
1. **Ready制御**: パイプライン全体が`d_ready`信号で制御されており、各ステージの動作はReadyがHの時のみ実行されます
2. **デコードベース制御**: T0ステージから派生する制御信号（`t0_mem_read_en`、`t0_last`、`t0_state_ready`）は、`t0_count`の値をデコードして生成されます
3. **シンプルなalways文**: 複雑な制御ロジックがalways文内に含まれておらず、コードがすっきりしています
4. **統一的制御**: パイプライン全体が一つのReady信号で統一的に制御されています

### 3.2 バーストリードパイプラインテストベンチ

**コード**: [burst_read_pipeline_tb.v](https://github.com/hwengjp/axi_pipeline_design_guide/blob/main/burst_read_pipeline_tb.v)

生成されたコードは無修正で使用可能でした。テストベンチは期待通りの動作をさせるために約5時間かかりました。詳細な指示を与えないで、XXと同様にというあいまいな指示ではリクエストされた側もうまく生成はできないということです。

### 3.3 実行用スクリプト

以下の指示でスクリプトを自動生成させます：
```
modelsim用にコンパイルと実行を行うスクリプトを作成してください。スクリプト名はテストベンチ名に合わせます。
```

## ライセンス

このプロジェクトは [Apache License 2.0](LICENSE) の下で公開されています。