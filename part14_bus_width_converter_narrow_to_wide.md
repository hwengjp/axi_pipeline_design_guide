# AXIバス設計ガイド 第14回 バス幅変換

## 目次

  - [1. はじめに](#1-はじめに)
  - [2. バス幅変換の分析](#2-バス幅変換の分析)
    - [2.1 幅が増大するケース](#21-幅が増大するケース)
    - [2.2 幅が減少するケース](#22-幅が減少するケース)
  - [3. 設計方針とアーキテクチャ](#3-設計方針とアーキテクチャ)
    - [3.1 基本設計原則](#31-基本設計原則)
    - [3.2 パイプライン構成](#32-パイプライン構成)
    - [3.3 制御信号の設計](#33-制御信号の設計)
  - [4. 実装詳細](#4-実装詳細)
    - [4.1 上位ビットから下位ビットへの変換](#41-上位ビットから下位ビットへの変換)
    - [4.2 下位ビットから上位ビットへの変換](#42-下位ビットから上位ビットへの変換)
    - [4.3 ストローブ信号の処理](#43-ストローブ信号の処理)
  - [5. テストベンチと検証](#5-テストベンチと検証)
    - [5.1 テスト戦略](#51-テスト戦略)
    - [5.2 境界値テスト](#52-境界値テスト)
    - [5.3 パフォーマンス検証](#53-パフォーマンス検証)
  - [6. まとめ](#6-まとめ)
  - [ライセンス](#ライセンス)

## 1. はじめに

このドキュメントはAIに読み込ませてコードを自動生成することを目標としています。

第14回では狭いデータバス幅から広いデータバス幅に変換するコンポーネントの実装について説明します。


## 2. バス幅変換の分析

### 2.1 バス幅変換組み合わせ表

変換の組み合わせは以下の通りです。

| 変換元\変換先 | 8bit | 16bit | 32bit | 64bit | 128bit | 256bit | 512bit | 1024bit |
|---------------|------|-------|-------|-------|--------|--------|--------|---------|
| **8bit**      | -    | ✅    | ✅    | ✅    | ✅     | ✅     | ✅     | ✅      |
| **16bit**     | -    | -     | ✅    | ✅    | ✅     | ✅     | ✅     | ✅      |
| **32bit**     | -    | -     | -     | ✅    | ✅     | ✅     | ✅     | ✅      |
| **64bit**     | -    | -     | -     | -     | ✅     | ✅     | ✅     | ✅      |
| **128bit**    | -    | -     | -     | -     | -      | ✅     | ✅     | ✅      |
| **256bit**    | -    | -     | -     | -     | -      | -      | ✅     | ✅      |
| **512bit**    | -    | -     | -     | -     | -      | -      | -      | ✅      |
| **1024bit**   | -    | -     | -     | -     | -      | -      | -      | -       |

**凡例**:
- ✅: バス幅増加（変換可能）
- -: 同一バス幅またはバス幅減少（変換対象外）

### 2.2 バス幅変換の具体例

32bitから64bitに変換する場合の動作を具体例で分析します。
アドレスのアライメントによって、下流側のストローブ位置が変わるという点に注意してください。

注：表の()内は計算上のアドレスとサイズです。

### 2.2.1 size=0(1バイト)、4ビートのバースト転送

|ビート|上流アドレス|下流サイズ|上流ストローブ|下流アドレス|下流サイズ|下流ストローブ|
|-----|-----------|---------|-------------|-----------|---------|-------------|
|0    |0x00       |0x0      |4'b0001      |0x00       |0x0      |8'b0000_0001 |
|1    |(0x01)     |(0x0)    |4'b0010      |(0x01)     |(0x0)    |8'b0000_0010 |
|2    |(0x02)     |(0x0)    |4'b0100      |(0x02)     |(0x0)    |8'b0000_0100 |
|3    |(0x03)     |(0x0)    |4'b1000      |(0x03)     |(0x0)    |8'b0000_1000 |

|ビート|上流アドレス|下流サイズ|上流ストローブ|下流アドレス|下流サイズ|下流ストローブ|
|-----|-----------|---------|-------------|-----------|---------|-------------|
|0    |0x04       |0x0      |4'b0001      |0x04       |0x0      |8'b0001_0000 |
|1    |(0x05)     |(0x0)    |4'b0010      |(0x05)     |(0x0)    |8'b0010_0000 |
|2    |(0x06)     |(0x0)    |4'b0100      |(0x06)     |(0x0)    |8'b0100_0000 |
|3    |(0x07)     |(0x0)    |4'b1000      |(0x07)     |(0x0)    |8'b1000_0000 |

### 2.2.1 size=2(4バイト)、4ビートのバースト転送

|ビート|上流アドレス|下流サイズ|上流ストローブ|下流アドレス|下流サイズ|下流ストローブ|
|-----|-----------|---------|-------------|-----------|---------|-------------|
|0    |0x00       |0x2      |4'b1111      |0x00       |0x2      |8'b0000_1111 |
|1    |(0x04)     |(0x2)    |4'b1111      |(0x04)     |(0x2)    |8'b1111_0000 |
|2    |(0x08)     |(0x2)    |4'b1111      |(0x08)     |(0x2)    |8'b0000_1111 |
|3    |(0x0C)     |(0x2)    |4'b1111      |(0x0C)     |(0x2)    |8'b1111_1000 |

|ビート|上流アドレス|下流サイズ|上流ストローブ|下流アドレス|下流サイズ|下流ストローブ|
|-----|-----------|---------|-------------|-----------|---------|-------------|
|0    |0x04       |0x2      |4'b1111      |0x04       |0x2      |8'b1111_0000 |
|1    |(0x08)     |(0x2)    |4'b1111      |(0x08)     |(0x2)    |8'b0000_1111 |
|2    |(0x0C)     |(0x2)    |4'b1111      |(0x0C)     |(0x2)    |8'b1111_0000 |
|3    |(0x10)     |(0x2)    |4'b1111      |(0x10)     |(0x2)    |8'b0000_1111 |

### 2.3 バス幅変換の計算方法

バス幅変換では、アドレスとサイズの情報から、下流側のストローブとデータの正確な位置を計算する必要があります。この計算は、データの整合性とストローブの正確性を保つために重要です。

#### 2.3.1 基本計算式（汎用バス幅変換）

**汎用バス幅変換の特徴**
- 入力: SOURCE_WIDTHビットのデータとストローブ
- 出力: TARGET_WIDTHビットのデータとストローブ
- 配置選択: RATIO個のセグメントから1つを選択

**基本パラメータ定義**
```systemverilog
// バス幅変換パラメータ
parameter int unsigned SOURCE_WIDTH = 32;        // 上流側バス幅
parameter int unsigned TARGET_WIDTH = 128;       // 下流側バス幅
parameter int unsigned RATIO = TARGET_WIDTH / SOURCE_WIDTH;  // 倍率

// セグメント判定用ビット位置（自動計算）
parameter int unsigned SEGMENT_BITS = $clog2(RATIO);                    // セグメント選択ビット数
parameter int unsigned SEGMENT_ADDR_LSB = $clog2(SOURCE_WIDTH/8);       // セグメント判定開始ビット
parameter int unsigned SEGMENT_ADDR_MSB = SEGMENT_ADDR_LSB + SEGMENT_BITS - 1;  // セグメント判定終了ビット
```

**セグメント選択ロジック**
```
segment_selector = address[SEGMENT_ADDR_MSB:SEGMENT_ADDR_LSB]
```
- `segment_selector`: セグメント番号（0, 1, 2, ..., RATIO-1）
- アドレスビットから自動的にセグメントを判定

**ストローブとデータの配置計算**
```
// セグメント位置の計算
start_bit = segment_selector * SOURCE_WIDTH

// ストローブとデータの配置（ビット連結による実装）
d_axi_wstrb = (u_axi_wstrb << start_bit)
d_axi_wdata = (u_axi_wdata << start_bit)
```
- 選択されたセグメントの位置にストローブとデータを配置
- シフト演算により正確なビット位置に配置
- 他のセグメントは0で初期化される

**アドレスアライメントチェック**
```
// SIZE値に応じたアライメントチェック
if (size == 2) begin  // 4バイト転送
    if (address[1:0] != 2'b00) begin
        $error("Address 0x%x not aligned for SIZE %0d", address, size);
    end
end else if (size == 1) begin  // 2バイト転送
    if (address[0] != 1'b0) begin
        $error("Address 0x%x not aligned for SIZE %0d", address, size);
    end
end
```
- SIZE値に応じた厳密なアドレスアライメントチェック
- アライメントされていない場合はエラー

#### 2.3.2 具体例による計算過程（汎用バス幅変換）

**例1: 32bit→64bit (2倍)、SIZE=0 (1バイト)、アドレス0x00**
```
RATIO = 64/32 = 2, SEGMENT_BITS = 1, SEGMENT_ADDR_LSB = 2
アドレス: 0x00 → segment_selector = address[2] = 0 → セグメント0
SIZE: 0 → ストローブパターン = 4'b0001
start_bit = 0 * 32 = 0
下流ストローブ = 4'b0001 << 0 = 8'b0000_0001
下流データ = 32'hAE << 0 = 64'h00000000_000000AE
```

**例2: 32bit→64bit (2倍)、SIZE=0 (1バイト)、アドレス0x04**
```
RATIO = 64/32 = 2, SEGMENT_BITS = 1, SEGMENT_ADDR_LSB = 2
アドレス: 0x04 → segment_selector = address[2] = 1 → セグメント1
SIZE: 0 → ストローブパターン = 4'b0001
start_bit = 1 * 32 = 32
下流ストローブ = 4'b0001 << 32 = 8'b0001_0000
下流データ = 32'hAE << 32 = 64'h000000AE_00000000
```

**例3: 32bit→128bit (4倍)、SIZE=2 (4バイト)、アドレス0x00**
```
RATIO = 128/32 = 4, SEGMENT_BITS = 2, SEGMENT_ADDR_LSB = 2
アドレス: 0x00 → segment_selector = address[3:2] = 2'b00 → セグメント0
SIZE: 2 → ストローブパターン = 4'b1111
start_bit = 0 * 32 = 0
下流ストローブ = 4'b1111 << 0 = 16'b0000_0000_0000_1111
下流データ = 32'h12345678 << 0 = 128'h00000000_00000000_00000000_12345678
```

**例4: 32bit→128bit (4倍)、SIZE=2 (4バイト)、アドレス0x08**
```
RATIO = 128/32 = 4, SEGMENT_BITS = 2, SEGMENT_ADDR_LSB = 2
アドレス: 0x08 → segment_selector = address[3:2] = 2'b10 → セグメント2
SIZE: 2 → ストローブパターン = 4'b1111
start_bit = 2 * 32 = 64
下流ストローブ = 4'b1111 << 64 = 16'b0000_1111_0000_0000
下流データ = 32'h12345678 << 64 = 128'h00000000_12345678_00000000_00000000
```

## 3. 仕様

### 3.1 パイプライン構成

パイプライン構成は、第７回のシンプルデュアルポートRAMの構成を流用します。リード側とライト側が完全に独立して動作します。

#### リード側パイプライン構成

リード側は2段構成のパイプラインで、バーストのビート数は変えずにデータだけを変換します：

```
u_r_Payload -> [T0] -> [T1] -> d_r_Payload
                ^       ^
                |       |
u_r_Ready   <-[AND]<---+-- <- d_r_Ready
                ^
                |
            [T0_State_Ready]
```

**リード側パイプラインの詳細**:

| 段階 | 機能 | 説明 | ペイロード増幅 | レイテンシ |
|------|------|------|------------|------------|
| T0 | アドレスカウンタとRE制御 | バースト転送の制御とアドレス生成 | **1→N個に増加** | 1クロック |
| T1 | 変換回路 | データを変換 | **増幅なし**（N個維持） | 1クロック |

**リード側の特徴**:
- **T0ステージ**: バースト制御とアドレス生成、上流に対するReady制御
- **T1ステージ**: 変換回路（レイテンシ1）
- **総レイテンシ**: 2クロック（T0: 1 + T1: 1）

#### ライト側パイプライン構成

ライト側は3段構成のパイプラインで、2つのペイロードが合流する構成です。T0DとT0Aは同時並列に動作します：

```
u_w_Payload_D=> [T0D]=======++
                 ^          ||
                 |          ||
u_w_Ready_D   <-[AND]---+   ||
                 ^      |   ||
                 |      |   ||
       [T0D_Ready]      |   ||
                        |   ||
u_w_Payload_A=> [T0A] ===> [T1] => [T2] => [T3] => d_w_Payload
                 ^      |   ^       ^       ^   
                 |      |   |       |       |   
u_w_Ready_A   <-[AND]<--+---+-------+-------+--- <- d_w_Ready
                 ^ ^                     
                 | |        
       [T0A_Ready] |        
              [T0A_M_Ready]
```

**ライト側パイプラインの詳細**:

| 段階 | 機能 | 説明 | ペイロード増幅 | レイテンシ |
|------|------|------|------------|------------|
| T0A/T0D | アドレス・データ並列処理 | アドレスとデータの同時並列処理 | **1→N個に増加** | 1クロック |
| T1 | アドレス・データ合流 | アドレスとデータの合流制御 | **増幅なし**（N個維持） | 1クロック |
| T2 | 変換回路 | データとストローブの変換 | **増幅なし**（N個維持） | 1クロック |

**ライト側の特徴**:
- **T0A/T0Dステージ**: アドレスとデータの同時並列処理
- **T1ステージ**: アドレス・データの合流制御
- **T2ステージ**: 変換回路（レイテンシ1）
- **総レイテンシ**: 3クロック（T0A/T0D: 1 + T1: 1 + T2: 1）

#### パイプライン制御の特徴

**独立動作**:
- リード・ライトのパイプラインが完全に独立して動作
- 同一アドレスへの同時アクセスも制御せず実行
- 各パイプラインが独自のReady制御で動作

**Ready制御**:
- 各ステージの動作は`d_ready`がHの時のみ実行
- パイプライン全体がReady信号で統一的に制御
- 上流へのReady信号は非同期ANDで生成

**メモリレイテンシ**:
- **リード側**: メモリレイテンシ2を採用（FPGAのBRAMの構造による要件）
- **ライト側**: メモリレイテンシ1を採用（書き込みは即座に実行）
- 論理合成ツールでの最適化が容易


## ライセンス

Licensed under the Apache License, Version 2.0 - see [LICENSE](https://www.apache.org/licenses/LICENSE-2.0) file for details.
