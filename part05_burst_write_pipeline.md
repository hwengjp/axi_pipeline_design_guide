# AXIバスのパイプライン回路設計ガイド ～ 第５回 Payloadが合流するパイプラインAXIライトデータチャネルの模擬

## 目次

- [AXIバスのパイプライン回路設計ガイド ～ 第５回 Payloadが合流するパイプラインAXIライトデータチャネルの模擬](#axiバスのパイプライン回路設計ガイド--第５回-payloadが合流するパイプラインaxiライトデータチャネルの模擬)
  - [目次](#目次)
  - [1. はじめに](#1-はじめに)
  - [2. 動作原理](#2-動作原理)
    - [2.1 データ合流とは](#21-データ合流とは)
    - [2.2 通常のReadyのシーケンス](#22-通常のreadyのシーケンス)
    - [2.3 Payloadが合流する場合のシーケンス](#23-payloadが合流する場合のシーケンス)
      - [パイプライン構成](#パイプライン構成)
  - [3. サンプルコード](#3-サンプルコード)
    - [3.1 バーストライトパイプラインモジュール](#31-バーストライトパイプラインモジュール)
    - [3.2 バーストライトパイプラインテストベンチ](#32-バーストライトパイプラインテストベンチ)
    - [3.3 実行用スクリプト](#33-実行用スクリプト)
  - [ライセンス](#ライセンス)

---

## 1. はじめに

このドキュメントはAIに読み込ませてコードを自動生成することを目標としています。

本記事では、パイプライン処理においてデータが合流する場合のAXIライトデータチャネルの動作を模擬します。前回までに学んだパイプライン処理の基本概念を応用し、実際のハードウェア設計でよく遭遇する「バーストライト」シナリオを扱います。

バーストライトは、アドレスリクエストとライトデータが合流するシナリオです。パイプラインの途中で1つのPayload（アドレス）がバースト回数分に膨らみます。この膨らんだアドレスは書き込みデータに合流します。Payload-1(アドレス)の個数が増えるパイプラインステージより上流のパイプラインを停止して待機させる必要があります。また、Payload-1(アドレス)はPayload-2(データ)と合流しさらにPayload-3(レスポン)に受け渡されます。Readyの発生源はPayload-1(アドレス)のバースト、Payload-2(データ)の書き込み可能かどうか、Payload-3(レスポン)の下流側から入力されるReadyの３箇所あります。この３つのパイプラインにできるだけ無駄なサイクルが発生しない実装を考えます。

AXIライトチャネルの特徴を整理します：

- **アドレスチャネル**: 書き込みアドレスとバースト情報を伝達
- **データチャネル**: 実際のデータとストローブ信号を伝達
- **レスポンスチャネル**: 書き込み完了の応答を伝達

このようにあらゆる設計を本質要素抽象化により検討内容をシンプルにして進めます。

ライトパイプランの実装は管理するチャネルが３つになり、またReadyの条件が複雑化するため難易度が一気に上がります。しかしながら、ここまで進めてきた単純化・ルール化によって先の見通しはかなりいいはずです。

## 2. 動作原理

### 2.1 データ増幅シナリオ

データ増幅は第４回で解説した通り、パイプライン処理において1つの入力データが複数の出力データに変換される現象です。特に**バーストアクセス**では、1つのリクエストに対して複数のデータ応答が返されます。これはリードと同様にライトでも発生します。データ増幅の実装方法はすでに学んだ方法を使用します。

## 3. ２つのペイロードが合流するパイプライン

T0Aはアドレスをカウントする回路。T0Dはデータパイプラインをアドレスパイプラインと同じ位置に合わせる。
T1はT0AとT0Dの制御をすると同時に、アドレス、データ、WEを生成する。
T2はライトの結果としてレスポンスを生成する。この回路では、書き込みが正常である証にアドレスとデータが同じでWEがアサートされているかどうかをチェックする。異常がなければT1のLASTの次のサイクルでダミーレスポンスのペイロードとしてバーストの最終アドレスを出力する。それ以外の時はペイロードに不定を出力する。

### 2.2 複数のReadyを制御するシナリオ

Ready信号は、アドレスチャネルのデータ増幅によるReady、データチャネルの書き込み待ちによるReady、レスポンスチャネルの最下流からのReadyの3つあります。データチャネルのReadyを除くと第4回の構造がそのまま使えます。

データチャネルの書き込み待ちの条件は2つあります：
1. アドレスが有効でデータが無効な場合
2. 書き込む先のメモリーがリードで占有されていた場合

この条件が発生した場合にデータチャネルのReadyをネゲートしてアドレスチャネルを止めます。第4回と同様に複数のReadyのマージは非同期の論理ANDです。
この章の回路では単純化のために２のリードとの競合は発生しないものとします。

Readyの制御について説明します。
このパイプライン全体のイネーブルを制御するd_Readyはレスポンスチャネルから入力されます。このd_ReadyがネゲートされるとT0,T1,T2のパイプラインを停止します。d_Readyは途中のパイプラインで生成されるReadyと非同期ANDされて上流に渡されます。
T1はデータとアドレスを待ち合わせるためのT0A_M_ReadyとT0D_M_Readyを生成します。T0A_M_Readyがアサートされる条件はT0DがValid && T0Aがnot Valid またはT0DとT0Aの両方がnot Valid　またはT0DとT0Aの両方がValidです。T0D_M_Readyがアサートされる条件は、T0Dがnot Valid && T0AがValid またはT0DとT0Aの両方がnot Valid またはT0DとT0Aの両方がValidです。T0A_M_ReadyとT0D_M_Readyはd_Readyと非同期ANDされて上流に渡されます。
T0Dはデータパイプラインです。T0D_Ready=Hで上流のペイロードがValidの場合にペイロードをラッチします。
T0Aはアドレスパイプラインです。第４回の2.3章で説明したアドレスの回路と同じ動作をします。バーストの管理のためにT0A_Readyが生成されます。このT0A_ReadyはT0A_M_Readyと非同期ANDされて上流に渡されます。

```
u_Payload_D=> [T0D]=======++
               ^          ||
               |          ||
u_Ready_D   <-[AND]---+   ||
               ^      |   ||
               |      |   ||
     [T0D_Ready]      |   ||
                      |   ||
u_Payload_A=> [T0A] ===> [T1] => [T2] => d_Payload
               ^      |   ^       ^   
               |      |   |       |   
u_Ready_A   <-[AND]<--+---+-------+--- <- d_Ready
               ^ ^                     
               | |        
     [T0A_Ready] |        
            [T0A_M_Ready]
```

### 4. シーケンス　バースト長４、データは連続して来る、d_readyはアサートのままのシーケンス
```
Clock        : 123456789012345678901
Address      : xxxxxx044448888xxxxxx
Length       : xxxxxx333333333xxxxxx
Valid        : ______HHHHHHHHHHHH___
Ready        : HHHHHHH___H___H___HHH

T0A_State    : 000000011121112111200
T0A_Count    : FFFFFFF321032103210FF
T0A_Mem_Adr  : xxxxxxx0123456789ABxx
T0A_Mem_RE   : _______HHHHHHHHHHHH__
T0A_Valid    : _______HHHHHHHHHHHH__
T0A_Last     : __________H___H___H__
T0A_Ready    : HHHHHHH___H___H___HHH
u_Ready_A    : HHHHHHH___H___H___HHH

Data         : xxxxxxx044448888xxxxxx
Valid        : _______HHHHHHHHHHHH___
Ready        : HHHHHHH___H___H___HHH

T0D_Mem_Dat  : xxxxxx0123456789ABxx
T0D_Mem_WE   : ______HHHHHHHHHHHH__
T0D_Valid    : ______HHHHHHHHHHHH__
T0D_Last     : _________H___H___H__
T0D_Ready    : HHHHHHH___H___H___HHH
u_Ready_D    : HHHHHHH___H___H___HHH




d_Response   : xxxxxxxxx001122333445566778899AABB__
d_Valid      : _________HHHHHHHHHHHHHH_____________
d_Ready      : HHHHHHHHHHHHHHHHHHHH
```

```
part05_payload_merge_pipeline.mdの２章と３章を読んでコードの作成をお願いします。モジュール名はburst_write_pipelineです。
アドレスパイプラインの実装は、burst_read_pipeline.vを参照してください。
```
```
T1 stageの出力をデバッグ時に検証できるようにテスト信号としてポートに出してください。出す信号は、
t1_addr
t1_data
t1_we
t1_valid
t1_last
d_ready
この信号の頭にtest_の文字を追加してassign文で代入して出力します。
```
```
テストベンチも実装お願いします。テストベンチはburst_read_pipeline_tb.svを参考にしてください。
テストデータと期待値は最初に配列として用意しておきます。配列はqueue型配列を使用してください。
テストのシナリオは3章に書かれています。
```


## 5. 本質要素抽象化とは

本質要素抽象化とは、複雑な設計課題を基本的な要素に分解し、それぞれの要素を独立して検討することで、全体の設計をシンプルにする手法です。複雑なシステムを設計する際、すべての要素を同時に考慮すると設計が困難になります。本質要素抽象化では、システムを制御要素、データ要素に分解します。

また、名称は具体名ではなく本質的にその機能を指し示す抽象的な名称にして、同じグループであるかそれとも別のグループであるかを明確にします。ここまで使用された抽象的な名称はReady、Valid、Payloadです。パイプラインは本質的にこの3種類の信号で説明が可能です。

### 抽象化の重要性

抽象化により、具体的な実装詳細に囚われることなく、システムの本質的な動作を理解できます。例えば、AXIプロトコルの詳細な信号名（AWVALID、WREADY、BRESPなど）ではなく、Ready、Valid、Payloadという抽象的な概念で考えることで、パイプラインの基本動作を理解しやすくなります。

### 3つの基本要素

**Ready**: データを受け取れる状態を示す制御信号
**Valid**: データが有効であることを示す制御信号  
**Payload**: 転送されるデータそのもの

この3つの要素により、あらゆるパイプラインの動作を統一的に記述できます。具体的なプロトコルや信号名に関係なく、パイプラインの本質的な動作を理解するための強力なツールとなります。

## 4. 実行用スクリプトの生成

シミュレータのコンパイル・実行スクリプトは以下のように指示して自動生成させます
```
burst_write_pipeline_tb.svのmodelsim用にコンパイルと実行を行うスクリプトを作成してください。スクリプト名はテストベンチ名に合わせます。
```

---

## ライセンス

Licensed under the Apache License, Version 2.0 - see [LICENSE](LICENSE) file for details.
